---
title: "weibull"
format: html
editor: visual
---


```{r}
library(brms)
library(tidybayes)
library(bayesplot)
library(loo)
library(reshape2)
```

```{r}
set.seed(2912) # Use the same number for all models
```



```{r}
priors <- c(
  prior(normal(1, 1), nlpar = "upper"),
  prior(normal(0.1, 0.1), nlpar = "slope"),
  prior(normal(12, 5), nlpar = "t50")
)
```

```{r}
full_model_f <- bf(
  viability_prop ~ upper / (1 + exp(-slope * (retrieval_time_months - t50))),
  upper + slope + t50 ~ species * depth_cm * location,
  nl = TRUE
)
```



```{r}
full_m_f <- brm(
  formula = full_model_f,
  data = all_data,
  prior = priors,
  chains = 4,
  cores = 4,
  seed = 2912,
  control = list(adapt_delta = 0.95),
  backend = "rstan"
)
```



```{r}
simple_model_f <- bf(
  viability_prop ~ upper / (1 + exp(-slope * (retrieval_time_months - t50))),
  upper + slope + t50 ~ species + depth_cm + location,
  nl = TRUE
)
```


```{r}
simple_m_f  <- brm(
  formula = simple_model_f,
  data = all_data,
  prior = priors,
  chains = 4,
  cores = 4,
  seed = 2912,
  control = list(adapt_delta = 0.95),
  backend = "rstan"
)
```





```{r}
loo_full_f <- add_criterion(full_m_f, "loo", moment_match = TRUE)
loo_simple_f <- add_criterion(simple_m_f, "loo", moment_match = TRUE)

loo_compare(loo_full_f, loo_simple_f)
```






```{r}
red_model1_f <- bf(
  viability_prop ~ upper / (1 + exp(-slope * (retrieval_time_months - t50))),
  upper + slope + t50 ~ species * depth_cm,
  nl = TRUE
)
```


```{r}
red_m1_f  <- brm(
  formula = red_model1_f,
  data = all_data,
  prior = priors,
  chains = 4,
  cores = 4,
  seed = 2912,
  control = list(adapt_delta = 0.95),
  backend = "rstan"
)
```

```{r}
loo_red1_f <- add_criterion(red_m1_f, "loo", moment_match = TRUE)

loo_compare(loo_full_f, loo_red1_f)
```


```{r}
red_model2_f <- bf(
  viability_prop ~ upper / (1 + exp(-slope * (retrieval_time_months - t50))),
  upper + slope + t50 ~ species * location,
  nl = TRUE
)
```


```{r}
red_m2_f  <- brm(
  formula = red_model2_f,
  data = all_data,
  prior = priors,
  chains = 4,
  cores = 4,
  seed = 2912,
  control = list(adapt_delta = 0.95),
  backend = "rstan"
)
```

```{r}
loo_red2_f <- add_criterion(red_m2_f, "loo", moment_match = TRUE)

loo_compare(loo_full_f, loo_red2_f)
```

```{r}
red_model3_f <- bf(
  viability_prop ~ upper / (1 + exp(-slope * (retrieval_time_months - t50))),
  upper + slope + t50 ~ location,
  nl = TRUE
)
```


```{r}
red_m3_f  <- brm(
  formula = red_model3_f,
  data = all_data,
  prior = priors,
  chains = 4,
  cores = 4,
  seed = 2912,
  control = list(adapt_delta = 0.95),
  backend = "rstan"
)
```

```{r}
loo_red3_f <- add_criterion(red_m3_f, "loo", moment_match = TRUE)

loo_compare(loo_red2_f, loo_red3_f)
```


```{r}
red_model4_f <- bf(
  viability_prop ~ upper / (1 + exp(-slope * (retrieval_time_months - t50))),
  upper + slope + t50 ~ 1,
  nl = TRUE
)
```


```{r}
red_m4_f  <- brm(
  formula = red_model4_f,
  data = all_data,
  prior = priors,
  chains = 4,
  cores = 4,
  seed = 2912,
  control = list(adapt_delta = 0.95),
  backend = "rstan"
)
```

```{r}
loo_red4_f <- add_criterion(red_m4_f, "loo", moment_match = TRUE)

loo_compare(loo_red2_f, loo_red4_f)
```





```{r}
new_data <- expand.grid(
  retrieval_time_months = seq(0, 60, by = 1),
  species = unique(all_data$species),
#  depth_cm = unique(all_data$depth_cm),
  location = unique(all_data$location)
)

preds <- fitted(red_m2_f, newdata = new_data, probs = c(0.025, 0.975))
new_data$predicted <- preds[, "Estimate"]
new_data$lower_CI <- preds[, "Q2.5"]
new_data$upper_CI <- preds[, "Q97.5"]
```


```{r}
new_data %>% 
  mutate(population = case_when(
  species == "Palmer amaranth" & location == "Lubbock" ~ "PA-LBK",
  species == "Palmer amaranth" & location == "College Station" ~ "PA-CS",
  species == "Palmer amaranth" & location == "Corpus Christi" ~ "PA-CC",
  species == "waterhemp" & location == "Lubbock" ~ "WH-LBK",
  species == "waterhemp" & location == "College Station" ~ "WH-CS",
  species == "waterhemp" & location == "Corpus Christi" ~ "WH-CC"
  )) %>%
  mutate(
    population = factor(population,
      levels = c("PA-LBK", "PA-CS", "PA-CC",
                 "WH-LBK", "WH-CS", "WH-CC")
    )
  ) -> new_data1
```

```{r}
pop_colors <- c(
  "PA-LBK" = "#E41A1C",
  "PA-CS"  = "#377EB8",
  "PA-CC"  = "#4DAF4A",
  "WH-LBK" = "#984EA3",
  "WH-CS"  = "#FF7F00",
  "WH-CC"  = "#A65628"
)
```


```{r}
new_data1 %>% 
  ggplot(aes(
  x = retrieval_time_months,
  y = predicted * 100,
  group = population,  # group aesthetics
  shape = population,
  color = population,
  linetype = population,
  fill = population
)) +
  geom_line(size = 1.2) +
  geom_jitter(
    data = all_data,
    aes(y = viability_prop * 100),
    alpha = 0.1,
    size = 3
  ) +
  labs(x = "Month after burial", y = "Viable seeds (%)") +
  geom_ribbon(aes(
    ymin = lower_CI * 100,
    ymax = upper_CI * 100, group = population
  ), color = NA, alpha = 0.1) +
  labs(x = "Month after burial", y = "Viable seeds (%)") +
  scale_y_continuous(limits = c(0, 107), breaks = seq(0, 100, 25)) +
  scale_x_continuous(limits = c(0, 60), breaks = seq(0, 60, 12)) +
  scale_shape_manual(values = c(16, 17, 18, 15, 8, 3)) +
  scale_color_manual(values = pop_colors) +
  scale_fill_manual(values = pop_colors) +
  theme_foundation() +
  theme(
    legend.background = element_blank(),
    legend.title = element_blank(),
    legend.box = element_blank(),
    legend.key = element_blank(),
    axis.title = element_blank(),
    axis.text = element_text(size = 12),
    strip.text = element_text(size = 12, face = "bold"),
    legend.position = "bottom",
    legend.direction = "horizontal"
  ) + 
  guides(
  color = guide_legend(override.aes = list(shape = c(16, 17, 18, 15, 8, 3)), nrow = 1),
  shape = "none",  # suppress separate shape legend
  fill = "none",   # suppress separate fill legend
  size = "none"    # suppress separate size legend
) -> fig_viab


ggsave("figures/seed_viability_2.png", width=6, height=6)
```

```{r}
unique(all_data$population)
```


```{r}
# Extract all posterior draws
posterior_draws <- as_draws_df(red_m2_f)
names(posterior_draws)
```


```{r}
get_param_for_group <- function(draws_df, param, species, location) {
  base <- draws_df[[paste0("b_", param, "_Intercept")]]

  # Reference levels
  ref_species <- "Palmer amaranth"
  ref_location <- "Corpus Christi"

  # Term names in the posterior
  sp_term <- paste0("b_", param, "_species", gsub(" ", "", species))
  loc_term <- paste0("b_", param, "_location", gsub(" ", "", location))
  inter_term <- paste0("b_", param, "_species", gsub(" ", "", species),
                       ":location", gsub(" ", "", location))
  inter_term_alt <- paste0("b_", param, "_location", gsub(" ", "", location),
                           ":species", gsub(" ", "", species))

  value <- base

  # Add main effect if not reference
  if (species != ref_species && sp_term %in% names(draws_df)) {
    value <- value + draws_df[[sp_term]]
  }

  if (location != ref_location && loc_term %in% names(draws_df)) {
    value <- value + draws_df[[loc_term]]
  }

  # Add interaction term only if not the reference species
  if (species != ref_species) {
    if (inter_term %in% names(draws_df)) {
      value <- value + draws_df[[inter_term]]
    } else if (inter_term_alt %in% names(draws_df)) {
      value <- value + draws_df[[inter_term_alt]]
    }
  }

  return(value)
}
```


```{r}
# --- 3. Prepare species × location combinations ---
group_levels <- all_data %>%
  distinct(species, location) %>%
  arrange(species, location)
```


```{r}
# --- 4. Set ET targets ---
Y_targets <- c(ET1 = 0.01, ET20 = 0.20, ET50 = 0.5, ET80 = 0.8)

# --- 5. Compute ETs by species × location ---
et_by_group_all <- pmap_dfr(group_levels, function(species, location) {
  
  # Extract posterior draws for this species-location combination
  upper <- get_param_for_group(posterior_draws, "upper", species, location)
  slope <- get_param_for_group(posterior_draws, "slope", species, location)
  t50   <- get_param_for_group(posterior_draws, "t50", species, location)
  
  # Compute ET (effective time) for each Y target
  ET_mat <- sapply(Y_targets, function(Y_target) {
    t50 - (1 / slope) * log((upper / Y_target) - 1)
  })
  
  # Summarize posterior distribution: median and 95% CI
  map_dfr(seq_along(Y_targets), function(i) {
    tibble(
      species = species,
      location = location,
      ET_target = names(Y_targets)[i],
      median_ET = median(ET_mat[, i]),
      lower_CI = quantile(ET_mat[, i], 0.025),
      upper_CI = quantile(ET_mat[, i], 0.975)
    )
  })
})


# --- 6. View results ---
et_by_group_all
```

```{r}
et_by_group_all %>% 
  filter(ET_target == "ET1") 
```

```{r}
fig_viab +
  geom_vline(data = et_by_group_all %>% 
  mutate(population = case_when(
  species == "Palmer amaranth" & location == "Lubbock" ~ "PA-LBK",
  species == "Palmer amaranth" & location == "College Station" ~ "PA-CS",
  species == "Palmer amaranth" & location == "Corpus Christi" ~ "PA-CC",
  species == "waterhemp" & location == "Lubbock" ~ "WH-LBK",
  species == "waterhemp" & location == "College Station" ~ "WH-CS",
  species == "waterhemp" & location == "Corpus Christi" ~ "WH-CC"
  )) %>%
  mutate(
    population = factor(population,
      levels = c("PA-LBK", "PA-CS", "PA-CC",
                 "WH-LBK", "WH-CS", "WH-CC")
    )
  ) %>% 
  filter(ET_target == "ET80",
         population=="PA-CS"), aes(xintercept=median_ET)) +
  geom_hline(yintercept = 80)
```


```{r}
# --- 1. Choose species × location combinations to compare ---
# Example: compare Palmer amaranth at Lubbock vs College Station
species_a <- "palmeri"
location_a <- "Lubbock"

species_b <- "palmeri"
location_b <- "CollegeStation"   # Use the same naming as in your model terms

# Choose which ET target to compare ("ET1", "ET20", "ET50", "ET80")
ET_to_compare <- "ET50"
```


```{r}
# --- 2. Helper function to compute ET draws for a given species × location ---
get_ET_draws <- function(species, location, Y_target) {
  upper <- get_param_for_group(posterior_draws, "upper", species, location)
  slope <- get_param_for_group(posterior_draws, "slope", species, location)
  t50   <- get_param_for_group(posterior_draws, "t50", species, location)
  
  t50 - (1 / slope) * log((upper / Y_target) - 1)
}



# --- 3. Compute posterior ET draws for both combinations ---
ET_a <- get_ET_draws(species_a, location_a, Y_targets[ET_to_compare])
ET_b <- get_ET_draws(species_b, location_b, Y_targets[ET_to_compare])


# --- 4. Compare posterior ET draws ---
diff <- ET_a - ET_b
mean_diff <- mean(diff)
ci_diff <- quantile(diff, c(0.025, 0.975))
prob_a_gt_b <- mean(diff > 0)



# --- 5. Report results ---
cat(sprintf("Comparison at %s:\n%s (%s) vs %s (%s)\n", 
            ET_to_compare, species_a, location_a, species_b, location_b))
cat(sprintf("Mean difference: %.2f\n", mean_diff))
cat(sprintf("95%% credible interval: [%.2f, %.2f]\n", ci_diff[1], ci_diff[2]))
cat(sprintf("Pr(%s_%s > %s_%s): %.1f%%\n", 
            species_a, location_a, species_b, location_b, 100 * prob_a_gt_b))
```

```{r}
# --- Build full posterior ET draws (species × location) ---
et_draws_long <- all_data %>%
  distinct(species, location) %>%
  arrange(species, location) %>%
  pmap_dfr(function(species, location) {
    
    # Extract posterior parameter draws
    upper <- get_param_for_group(posterior_draws, "upper", species, location)
    slope <- get_param_for_group(posterior_draws, "slope", species, location)
    t50   <- get_param_for_group(posterior_draws, "t50",   species, location)
    
    # Compute ETs for all Y targets
    ET_mat <- sapply(Y_targets, function(Y_target) {
      t50 - (1 / slope) * log((upper / Y_target) - 1)
    })
    
    # Return as long tibble
    tibble(
      species = species,
      location = location,
      draw = seq_along(upper),
      ET1 = ET_mat[, "ET1"],
      ET20 = ET_mat[, "ET20"],
      ET50 = ET_mat[, "ET50"],
      ET80 = ET_mat[, "ET80"]
    ) %>%
      pivot_longer(
        cols = starts_with("ET"),
        names_to = "ET_target",
        values_to = "ET_value"
      )
  })
```


```{r}
et_draws_long %>%
  group_by(species, location, ET_target) %>% 
  filter(ET_target == "ET80") %>%
  summarise(min_ET = min(ET_value)) 
```

```{r}
et_draws_long %>% 
  mutate(population = case_when(
  species == "Palmer amaranth" & location == "Lubbock" ~ "PA-LBK",
  species == "Palmer amaranth" & location == "College Station" ~ "PA-CS",
  species == "Palmer amaranth" & location == "Corpus Christi" ~ "PA-CC",
  species == "waterhemp" & location == "Lubbock" ~ "WH-LBK",
  species == "waterhemp" & location == "College Station" ~ "WH-CS",
  species == "waterhemp" & location == "Corpus Christi" ~ "WH-CC"
  )) %>%
  mutate(
    population = factor(population,
      levels = c("PA-LBK", "PA-CS", "PA-CC",
                 "WH-LBK", "WH-CS", "WH-CC")
    )
  ) -> et_draws_long1
```


```{r}
et_draws_long1 %>% 
  filter(ET_target == "ET80") %>%
  mutate(group = factor(population, levels = c("PA-CC", "PA-CS", "PA-LBK", "WH-CC", "WH-CS", "WH-LBK"))) %>%
  ggplot(aes(x = reorder(group, ET_value, FUN = median), y = ET_value, fill = group)) +
  geom_violin(alpha = 0.6) +
  geom_boxplot(width = 0.1, outlier.shape = NA) +
  coord_flip() +
  labs(
    x = NULL,
    y = "Months after burial for 80% seed viability (ET80)"
  ) +
  theme_foundation() +
  scale_color_manual(values = pop_colors) +
  scale_fill_manual(values = pop_colors) +
  scale_y_continuous(limits=c(0,8)) +
  theme(
    axis.text = element_text(size = 11),
    axis.title = element_text(size = 12),
    legend.position = "none"
  ) -> fig_et_80

ggsave("figures/et80_violin_plot.png", width = 6, height = 5)
```



```{r}
et_draws_long1 %>% 
  filter(ET_target == "ET50") %>%
  mutate(group = factor(population, levels = c("PA-CC", "PA-CS", "PA-LBK", "WH-CC", "WH-CS", "WH-LBK"))) %>%
  ggplot(aes(x = reorder(group, ET_value, FUN = median), y = ET_value, fill = group)) +
  geom_violin(alpha = 0.6) +
  geom_boxplot(width = 0.1, outlier.shape = NA) +
  coord_flip() +
  labs(
    x = NULL,
    y = "Months after burial for 50% seed viability (ET50)"
  ) +
  theme_foundation() +
  scale_color_manual(values = pop_colors) +
  scale_fill_manual(values = pop_colors) +
  scale_y_continuous(limits = c(0, 10), breaks = seq(0, 10, 2)) +
  theme(
    axis.text = element_text(size = 11),
    axis.title = element_text(size = 12),
    legend.position = "none"
  ) -> fig_et_50

ggsave("figures/et50_violin_plot.png", width = 6, height = 5)

```





```{r}
et_draws_long1 %>% 
  filter(ET_target == "ET1") %>%
  mutate(group = factor(population, levels = c("PA-CC", "PA-CS", "PA-LBK", "WH-CC", "WH-CS", "WH-LBK"))) %>%
  ggplot(aes(x = reorder(group, ET_value, FUN = median), y = ET_value, fill = group)) +
  geom_violin(alpha = 0.6) +
  geom_boxplot(width = 0.1, outlier.shape = NA) +
  coord_flip() +
  labs(
    x = NULL,
    y = "Months after burial for 1% seed viability (ET1)"
  ) +
  theme_foundation() +
  scale_color_manual(values = pop_colors) +
  scale_fill_manual(values = pop_colors) +
  scale_y_continuous(limits = c(0, 50), breaks = seq(0, 50, 10)) +
  theme(
    axis.text = element_text(size = 11),
    axis.title = element_text(size = 12),
    legend.position = "none"
  ) -> fig_et_1

ggsave("figures/et1_violin_plot.png", width = 6, height = 5)
```

80% pairwise comparison heatmap

```{r}
# --- Filter for ET80 draws and prepare data ---
et80_wide <- et_draws_long1 %>%
  filter(ET_target == "ET80") %>%
  mutate(group = population) %>%
  dplyr::select(group, ET_value)
```


```{r}
# --- Nest by group and pivot to wide matrix ---
et80_matrix <- et80_wide %>%
  group_by(group) %>%
  summarise(draws = list(ET_value), .groups = "drop") %>%
  pivot_wider(names_from = group, values_from = draws) %>%
  unnest(cols = everything()) %>%
  as.data.frame()
```


```{r}
# --- Compute pairwise probabilities ---
group_ids80 <- colnames(et80_matrix)

pairwise_probs80 <- matrix(NA,
  nrow = length(group_ids80),
  ncol = length(group_ids80),
  dimnames = list(group_ids80, group_ids80)
)

for (i in seq_along(group_ids80)) {
  for (j in seq_along(group_ids80)) {
    if (i != j) {
      diff <- et80_matrix[[i]] - et80_matrix[[j]]
      pairwise_probs80[i, j] <- mean(diff > 0)
    } else {
      pairwise_probs80[i, j] <- NA
    }
  }
}
```


```{r}
# --- Convert to long format for plotting ---
heatmap_data80 <- melt(pairwise_probs80, varnames = c("Group1", "Group2"), value.name = "Pr_G1_gt_G2")
```


```{r}
# --- Create heatmap plot ---
ggplot(heatmap_data80, aes(x = Group2, y = Group1)) +
  geom_point(aes(color = Pr_G1_gt_G2, size = Pr_G1_gt_G2), shape = 16) +
  scale_color_gradient2(
    low = "#d73027", mid = "white", high = "#1a9850",
    midpoint = 0.5, limits = c(0, 1)
  ) +
  geom_text(aes(label=round(Pr_G1_gt_G2,2)), size = 2.8, color = "#333333") +
  scale_size_continuous(range = c(5, 9), limits = c(0, 1)) +
  guides(
    color = guide_legend(title = "Pr(G1 > G2)"),
    size = guide_legend(title = "Pr(G1 > G2)")
  ) +
  theme_foundation() +
  theme(
    axis.text.x = element_text(),
    legend.position = "none",
    axis.text = element_text(size = 11),
    axis.title = element_text(size = 12),
  ) +
  labs(
    x = "Group compared against (ET80)",
    y = "Group being evaluated (ET80)"
  ) -> fig_et_80_pair

ggsave("figures/et80_pairwise_heatmap.png", width = 7, height = 6)
```




50% pairwise comparison heatmap

```{r}
# --- Filter for ET50 draws and prepare data ---
et50_wide <- et_draws_long1 %>%
  filter(ET_target == "ET50") %>%
  mutate(group = population) %>%
  dplyr::select(group, ET_value)
```


```{r}
# --- Nest by group and pivot to wide matrix ---
et50_matrix <- et50_wide %>%
  group_by(group) %>%
  summarise(draws = list(ET_value), .groups = "drop") %>%
  pivot_wider(names_from = group, values_from = draws) %>%
  unnest(cols = everything()) %>%
  as.data.frame()
```


```{r}
# --- Compute pairwise probabilities ---
group_ids50 <- colnames(et50_matrix)

pairwise_probs50 <- matrix(NA,
  nrow = length(group_ids50),
  ncol = length(group_ids50),
  dimnames = list(group_ids50, group_ids50)
)

for (i in seq_along(group_ids50)) {
  for (j in seq_along(group_ids50)) {
    if (i != j) {
      diff <- et50_matrix[[i]] - et50_matrix[[j]]
      pairwise_probs50[i, j] <- mean(diff > 0)
    } else {
      pairwise_probs50[i, j] <- NA
    }
  }
}
```


```{r}
# --- Convert to long format for plotting ---
heatmap_data50 <- melt(pairwise_probs50, varnames = c("Group1", "Group2"), value.name = "Pr_G1_gt_G2")
```


```{r}
# --- Create heatmap plot ---
ggplot(heatmap_data50, aes(x = Group2, y = Group1)) +
  geom_point(aes(color = Pr_G1_gt_G2, size = Pr_G1_gt_G2), shape = 16) +
  scale_color_gradient2(
    low = "#d73027", mid = "white", high = "#1a9850",
    midpoint = 0.5, limits = c(0, 1)
  ) +
  geom_text(aes(label=round(Pr_G1_gt_G2,2)), size = 2.8, color = "#333333") +
  scale_size_continuous(range = c(5, 9), limits = c(0, 1)) +
  guides(
    color = guide_legend(title = "Pr(G1 > G2)"),
    size = guide_legend(title = "Pr(G1 > G2)")
  ) +
  theme_foundation() +
  theme(
    axis.text.x = element_text(),
    axis.text = element_text(size = 11),
    axis.title = element_text(size = 12),
    legend.position = "bottom"
  ) +
  labs(
    x = "Group compared against (ET50)",
    y = "Group being evaluated (ET50)"
  ) -> fig_et_50_pair

ggsave("figures/et50_pairwise_heatmap.png", width = 7, height = 6)
```








1% pairwise comparison heatmap

```{r}
# --- Filter for ET50 draws and prepare data ---
et1_wide <- et_draws_long1 %>%
  filter(ET_target == "ET1") %>%
  mutate(group = population) %>%
  dplyr::select(group, ET_value)
```


```{r}
# --- Nest by group and pivot to wide matrix ---
et1_matrix <- et1_wide %>%
  group_by(group) %>%
  summarise(draws = list(ET_value), .groups = "drop") %>%
  pivot_wider(names_from = group, values_from = draws) %>%
  unnest(cols = everything()) %>%
  as.data.frame()
```


```{r}
# --- Compute pairwise probabilities ---
group_ids1 <- colnames(et1_matrix)

pairwise_probs1 <- matrix(NA,
  nrow = length(group_ids1),
  ncol = length(group_ids1),
  dimnames = list(group_ids1, group_ids1)
)

for (i in seq_along(group_ids1)) {
  for (j in seq_along(group_ids1)) {
    if (i != j) {
      diff <- et1_matrix[[i]] - et1_matrix[[j]]
      pairwise_probs1[i, j] <- mean(diff > 0)
    } else {
      pairwise_probs1[i, j] <- NA
    }
  }
}
```


```{r}
# --- Convert to long format for plotting ---
heatmap_data1 <- melt(pairwise_probs1, varnames = c("Group1", "Group2"), value.name = "Pr_G1_gt_G2")
```


```{r}
# --- Create heatmap plot ---
heatmap_data1 %>% 
  ggplot(aes(x = Group2, y = Group1)) +
  geom_point(aes(color = Pr_G1_gt_G2, size = Pr_G1_gt_G2), shape = 16) +
  scale_color_gradient2(
    low = "#d73027", mid = "white", high = "#1a9850",
    midpoint = 0.5, limits = c(0, 1)
  ) +
  geom_text(aes(label=round(Pr_G1_gt_G2,2)), size = 2.7, color = "#333333") +
  scale_size_continuous(range = c(5, 9), limits = c(0, 1)) +
  guides(
    color = guide_legend(title = "Pr(G1 > G2)"),
    size = guide_legend(title = "Pr(G1 > G2)")
  ) +
  theme_foundation() +
  theme(
    axis.text.x = element_text(),
    axis.text = element_text(size = 11),
    axis.title = element_text(size = 12),   
    legend.position = "none",
  ) +
  labs(
    x = "Group compared against (ET1)",
    y = "Group being evaluated (ET1)"
  ) -> fig_et_1_pair

ggsave("figures/et1_pairwise_heatmap.png", width = 7, height = 6)
```




```{r}
library(patchwork)
```


```{r}
#| warning: false

(fig_et_80 + fig_et_50 + fig_et_1) /
  (fig_et_80_pair + fig_et_50_pair + fig_et_1_pair) +
  plot_annotation(tag_levels = "A")


ggsave("figures/Final_figure.png", width = 15, height = 9)
```





















